#! /usr/bin/env python3


import argparse
import datetime
import inspect
import os
import shutil
import signal
from pathlib import Path
from subprocess import Popen
from tempfile import TemporaryDirectory

from pylogics.parsers import parse_pltl

from pddl.formatter import domain_to_string, problem_to_string
from pddl.logic.base import Formula
from pddl.parser.domain import DomainParser
from pddl.parser.problem import ProblemParser
from planning_with_past.compiler import Compiler
from planning_with_past.utils.mapping_parser import mapping_parser

DEFAULT_OUTPUT_DIR: str = "output"
BIN_DIR = Path(inspect.getframeinfo(inspect.currentframe()).filename).parent
REPO_ROOT = BIN_DIR.parent
MYND_WRAPPER_PATH = BIN_DIR / "mynd_wrapper"
PLTLF_WRAPPER_PATH = BIN_DIR / "pltlf-planner"


def launch(cmd, cwd=None):
    """Launch a command."""
    print("Running command: ", " ".join(map(str, cmd)))
    process = Popen(
        args=cmd,
        encoding="utf-8",
        cwd=cwd,
    )
    try:
        process.wait()
    except KeyboardInterrupt:
        print("Interrupted")
    finally:
        if process.poll() is None:
            try:
                print("do killpg")
                os.killpg(os.getpgid(process.pid), signal.SIGTERM)
            except:
                print("killpg failed")
        if process.returncode != 0:
            print(f"return code {process.returncode}")
            exit(1)


def is_valid_file(arg):
    """Argparse validator for files to check for their existence."""
    if not os.path.exists(arg):
        raise FileNotFoundError("The file %s does not exist!" % arg)
    return Path(arg)


def does_not_exists(arg):
    """Argparse validator for files to check they do not exist."""
    if os.path.exists(arg):
        raise FileExistsError("The file %s already exists!" % arg)
    return Path(arg)


def parse_args():
    """Parse command-line arguments."""
    parser = argparse.ArgumentParser("pltlf-planner", description="A FOND planner for temporal goals in PLTLf")
    parser.add_argument("--domain", type=is_valid_file, required=True)
    parser.add_argument("--problem", type=is_valid_file, required=True)
    parser.add_argument("--formula", type=str, required=True)
    parser.add_argument("--map", dest="map_file", type=is_valid_file, default=None, required=False)
    parser.add_argument("--output-dir", type=str, default=DEFAULT_OUTPUT_DIR)
    parser.add_argument('-s', dest='strong', type=int, choices={0, 1}, default=0)
    parser.add_argument('--heuristic', dest='heuristic', type=str, choices={"ff"}, default="ff")
    return parser.parse_args()


def _process_output_dir(output_path: str, force: bool):
    """Process the output directory argument."""
    if force:
        shutil.rmtree(output_path, ignore_errors=True)
    elif os.path.exists(output_path):
        raise FileExistsError("The file %s already exists!" % output_path)
    Path(output_path).mkdir(parents=True)


if __name__ == '__main__':
    args = parse_args()
    start = datetime.datetime.now()
    with TemporaryDirectory() as tmpdir:
        new_domain_file = Path(tmpdir) / "new_domain.pddl"
        new_problem_file = Path(tmpdir) / "new_problem.pddl"
        cli_args =[PLTLF_WRAPPER_PATH,
            "--domain", args.domain,
            "--problem", args.problem,
            "--formula", args.formula,
            "--output-domain", str(new_domain_file),
            "--output-problem", str(new_problem_file),]
        if args.map_file:
            cli_args += ["--map", args.map_file,]
        launch(cli_args)
        end_compilation = datetime.datetime.now()
        elapsed_time_compilation = (end_compilation.timestamp() - start.timestamp())
        print(f"Compilation time: {elapsed_time_compilation} seconds")

        cli_args = [str(MYND_WRAPPER_PATH),
                    "-d", str(new_domain_file),
                    "-p", str(new_problem_file),
                    "-s", str(args.strong),
                    "--heuristic", str(args.heuristic)]
        launch(cli_args)
    # some code
    end_tool = datetime.datetime.now()
    end_tool_time = end_tool - end_compilation
    print(f"Tool time: {end_tool_time.total_seconds()} seconds")
    elapsed = end_tool - start
    print(f"Total time: {elapsed.total_seconds()} seconds")
