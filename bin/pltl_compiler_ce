#!/usr/bin/env python3

import argparse
import os
from pathlib import Path

from pylogics.parsers import parse_pltl

from pddl.formatter import domain_to_string, problem_to_string
from pddl.logic.base import Formula
from pddl.parser.domain import DomainParser
from pddl.parser.problem import ProblemParser
from planning_with_past.compiler import Compiler
from planning_with_past.utils.mapping_parser import mapping_parser

from GGpltl.launch_compilation_alt import compile_with_pddl_library

DEFAULT_NEW_DOMAIN_FILENAME: str = "new-domain.pddl"
DEFAULT_NEW_PROBLEM_FILENAME: str = "new-problem.pddl"


def is_valid_file(arg):
    """Argparse validator for files to check for their existence."""
    if not os.path.exists(arg):
        raise FileNotFoundError("The file %s does not exist!" % arg)
    return Path(arg)


def does_not_exists(arg):
    """Argparse validator for files to check they do not exist."""
    if os.path.exists(arg):
        raise FileExistsError("The file %s already exists!" % arg)
    return Path(arg)


def parse_args():
    """Parse command-line arguments."""
    parser = argparse.ArgumentParser("pltlf-planner", description="A FOND planner for temporal goals in PLTLf")
    parser.add_argument("--domain", type=is_valid_file, required=True)
    parser.add_argument("--problem", type=is_valid_file, required=True)
    parser.add_argument("--formula", type=parse_pltl, required=True)
    parser.add_argument("--map", dest="map_file", type=is_valid_file, default=None, required=False)
    parser.add_argument("--output-domain", type=str, default=DEFAULT_NEW_DOMAIN_FILENAME)
    parser.add_argument("--output-problem", type=str, default=DEFAULT_NEW_PROBLEM_FILENAME)
    return parser.parse_args()


def main(domain_path: Path, problem_path: Path, formula: Formula, map_path: Path, output_domain: str, output_problem: str):
    # output_domain_path = Path(output_domain)
    # output_problem_path = Path(output_problem)
    # domain_parser = DomainParser()
    # problem_parser = ProblemParser()
    # domain = domain_parser(domain_path.read_text())
    # problem = problem_parser(problem_path.read_text())
    # if map_path:
    #     mapping = mapping_parser(map_path.read_text(), formula)
    # else:
    #     mapping = None

    # compiler = Compiler(domain, problem, formula, mapping)
    # compiler.compile()
    # compiled_domain, compiled_problem = compiler.result

    # try:
    #     with output_domain_path.open("w") as dom:
    #         dom.write(domain_to_string(compiled_domain))
    #     with output_problem_path.open("w") as prob:
    #         prob.write(problem_to_string(compiled_problem))
    # except Exception:
    #     raise IOError(
    #         "[ERROR]: Something wrong occurred while writing the compiled domain and problem."
    #     )
    
    output_domain_path = Path(output_domain)
    output_problem_path = Path(output_problem)
    domain_parser = DomainParser()
    problem_parser = ProblemParser()
    domain = domain_parser(domain_path.read_text())
    problem = problem_parser(problem_path.read_text())

    if map_path:
        mapping = mapping_parser(map_path.read_text(), formula)
    else:
        mapping = None

    #formula = parse_pltl(formula)

    compiled_domain, compiled_problem, before_mapping = compile_with_pddl_library(domain, problem, formula, from_atoms_to_fluent=mapping)

    try:
        with output_domain_path.open("w") as dom:
            #dom.write(domain_to_string(compiled_domain) + '\n' + before_mapping)
            dom.write(domain_to_string(compiled_domain))
        with output_problem_path.open("w") as prob:
            prob.write(problem_to_string(compiled_problem))
    except Exception:
        raise IOError(
            "[ERROR]: Something wrong occurred while writing the compiled domain and problem."
        )


if __name__ == '__main__':
    arguments = parse_args()
    main(arguments.domain, arguments.problem, arguments.formula, arguments.map_file, arguments.output_domain, arguments.output_problem)
